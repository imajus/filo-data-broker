---
description: 
globs: 
alwaysApply: false
---
# Blockchain Integration Patterns

## Contract Management
- Use [FDBRegistry.js](mdc:lib/contracts/FDBRegistry.js) singleton for all contract interactions
- Contract address and ABI are stored in [FDBRegistry.json](mdc:lib/contracts/FDBRegistry.json)
- Access via `FDBRegistry.getInstance()` to ensure single contract instance

## Ethereum Signer Configuration
- Signer setup handled in [lib/signer.js](mdc:lib/signer.js)
- Requires `ETHEREUM_PRIVATE_KEY` environment variable
- Use [getSigner()](mdc:lib/signer.js) function for consistent signer access

## Dataset Purchase Flow
1. Check ownership with `contract.hasNFT(address)`
2. If not owned, call `contract.purchase(address, { value: price })`
3. Wait for transaction confirmation with `tx.wait()`
4. Set purchase state to prevent duplicate transactions

## Price Handling
- Contract stores prices in Wei (ethers.parseEther for conversion to Wei)
- Convert to human-readable format with `ethers.formatEther`
- Store prices as numbers in metadata for easier handling

## Dataset Metadata Format
Standard metadata structure returned by `getDatasetMetadata()`:
```javascript
{
  address: string,      // NFT contract address
  name: string,         // Dataset name
  description: string,  // Dataset description
  price: number,        // Price in ETH (not Wei)
  publicColumns: string[],
  privateColumns: string[],
  publicCid: string,    // IPFS CID for public data
  privateCid: string    // IPFS CID for encrypted private data
}
```

## Error Handling
- Contract errors bubble up as ethers.js exceptions
- Handle network connectivity issues gracefully
- Provide meaningful error messages for failed transactions

## Gas Optimization
- Use `hasNFT()` check before attempting purchases to avoid failed transactions
- Cache contract instances to avoid repeated deployments
- Consider gas estimation for purchase transactions if needed
